<?php
  require_once('includes/template.php');

  head([
    'title' => "Creating a Touch Keyboard Layout Part 2"
  ]);
?>

<h1 class="title" id="touch_layout_2">Creating a Touch Keyboard Layout Part 2</h1>
    
  <p>This article will continue the guide to creating a touch keyboard layout. In particular, we'll look in more detail at how keys
  are arranged, just what can be specified for each key, and lastly, how this all looks in the JSON code used to define the touch hold
  layout.</p>

  <h2><a name="id488340" id="id488340"></a>Key and Key Layer Organization</h2>

  <p>There are two issues that are immediately apparent when considering key layout on touch devices.</p>

  <p>First, on smaller touch devices, such as phones, if we try to display the same arrangement of keys that is used for a typical
  desktop keyboard, the keys are so small that it is difficult to reliably select the wanted key. If used in 'portrait' view, key
  widths are too narrow for our 'fat fingers':</p>
  
  <p><img src="<?= cdn('img/developer/90/touch_amharic_keyboard_4.png')?>"></p>

  <p>Or if in 'landscape' view, key heights are too small:</p>
  
  <p><img src="<?= cdn('img/developer/90/touch_amharic_keyboard_5.png')?>"></p>

  <p>The situation is improved markedly if we limit the number of keys per row to ten and have no more than four key
  rows:</p>
  
  <p><img src="<?= cdn('img/developer/90/touch_amharic_keyboard_6.png')?>"></p>

  <p>and, in landscape view:</p>
  
  <p><img src="<?= cdn('img/developer/90/touch_amharic_keyboard_7.png')?>"></p>

  <p>So which keys can be eliminated, and which keys must be on the base (default) layer? This brings us to the second point. When using
  phones and other touch layout devices rather than desktop keyboards, text entry is most often single-handed, which makes it best to
  avoid using the 'shift' layer for entering normal text. Secondary keyboard layers will, of course, still be usually needed for
  uppercase, numerals and symbols, but will be used much less frequently.</p>

  <p>Most desktop keyboards (for European languages, at least) are already laid out with no more than ten letter (or digit) keys per row,
  with the remaining keys being used for accented letters, punctuation and other non-letter input. So the obvious choice is to move
  non-letter keys (and accented letters) either to a secondary key layer, or to touch-hold ('pop-up') keys. The GFF Amharic
  desktop keyboard is fortunately also arranged with only ten letters per key row (other keys being used for punctuation, etc.), as the
  many different characters in the Amharic 'abugida' are generated by multi-letter sequences rather than being displayed on
  separate keys. The Geez script does not have both upper-case and lower-case forms, so those initial consonants that require use of the
  'shift' layer on the desktop keyboard have been added to the corresponding base-layer key as touch-hold keys:</p>
  
  <p><img src="<?= cdn('img/developer/90/touch_amharic_keyboard_8.png')?>"></p>

  <p>Arrangement of punctuation and other non-letter keys is more flexible as mobile users are generally familiar with using touch-hold
  keys or a secondary key layer for finding and entering digits and special characters. However, some punctuation characters are used so
  frequently that they need to be on the base layer. For the GFF Amharic keyboard, the most frequently used punctuation characters can be
  output from the base layer using standard or touch-hold keys. The Geez word space character, in particular, is so frequently used that
  it was considered useful to add it to the bottom key, adjacent to the space bar, as is sometimes done for other scripts, such as
  Japanese, on desktop (physical) keyboards.</p>

  <h2><a name="id488436" id="id488436"></a>Arranging keys with the layout editor</h2>

  <p>The Keyman Developer 9 layout editor really makes it quite easy to try different key layouts and choose what is best for your
  keyboard. The image below highlights just how, for any selected key, using the clickable icons circled, a key row can be added above
  (1) or below (2), a key added before (3) or after (4), the selected key deleted (5), and how an array of touch-hold keys (called
  "subkeys" in the current Keyman Developer 9 beta) can be added (6).</p>
  
  <p><img src="<?= cdn('img/developer/90/touch_amharic_keyboard_9.png')?>"></p>

  <h2><a name="id488433" id="id488433"></a>Key properties</h2>

  <p>For each visual key, the appearance and behaviour is determined by a number of properties:</p>

  <h3><a name="id488482" id="id488482"></a>Key Code</h3>

  <p>Each key must be given an identifying key code which is unique to the key layer. Key codes by and large correspond to the virtual
  key codes used when creating a keyboard program for a desktop keyboard, and should start with <code>K_</code>, for keys mapped to standard Keyman
  virtual key names, e.g. <code>K_HYPHEN</code>, and <code>T_</code> or <code>U_</code> for user-defined names, e.g. <code>T_ZZZ</code>. If keyboard rules exist matching the key code in
  context, then the output from the key will be determined by the processing of those rules. It is usually best to include explicit rules
  to manage the output from each key, but if no rules matching the key code are included in the keyboard program, and the key code
  matches the pattern <code>U_<var>xxxx</var></code> (where <code><var>xxxx</var></code> is a 4-digit uppercase hex string), then the Unicode character <code>U+<var>xxxx</var></code> will be output. The key
  code is always required, and a default code will usually be generated automatically by Keyman Developer 9.</p>

  <div class="itemizedlist">
    <ul type="opencircle">
      <li class="c1">
        <p><code><var>K_xxxx</var></code> is used for a standard Keyman Desktop key name, e.g. <code>K_W</code>, <code>K_ENTER</code>. You cannot make up your own <code>K_<var>xxxx</var></code> names. Many of
        the <code>K_</code> ids have overloaded output behaviour, for instance, if no rule is matched for <code>K_W</code>, Keyman will output 'w' when it
        is touched. The standard key names are listed in <a class="link" href="/developer/language/guide/virtual-keys" title=
        "Virtual Keys and Virtual Character Keys">Virtual Keys and Virtual Character Keys</a>. Typically, you would use only the
        "common" virtual key codes.</p>
      </li>

      <li class="c1">
        <p><code>T_<var>xxxx</var></code> is used for any user defined names, e.g. <code>T_SCHWA</code>. If you wanted to use it, <code>T_ENTER</code> would also be valid. If no rule
        matches it, the key will have no output behaviour.</p>
      </li>

      <li class="c1">
        <p><code>U_<var>####</var></code> is used as a shortcut for a key that will output that single Unicode value, if no rule matches it. This is similar to
        the overloaded behaviour for <code>K_</code> ids. Thus <code><var>####</var></code> must be a valid hexadecimal value. E.g. <code>U_0259</code> would generate a schwa if no rule
        matches. It is still valid to have a rule such as <code>+ [U_0259] > ...</code></p>
      </li>
    </ul>
  </div>

  <p>Any key can be used to switch keyboard layers (see below), but the following layer-switching key codes have been added for switching
  to some commonly used secondary layers:</p>

  <div class="table">
    <a name="id488449" id="id488449"></a>

    <p class="title"><b>Table 2.1. </b></p>

    <div class="table-contents">
      <table border="1">
        <colgroup>
          <col>
          <col>
        </colgroup>

        <thead>
          <tr>
            <th align="left">Identifier</th>
            <th align="left">Value</th>
          </tr>
        </thead>

        <tbody>
          <tr>
            <td align="left"><code>K_NUMERALS</code></td>
            <td align="left"><code>261</code></td>
          </tr>

          <tr>
            <td align="left"><code>K_SYMBOLS</code></td>
            <td align="left"><code>262</code></td>
          </tr>

          <tr>
            <td align="left"><code>K_CURRENCIES</code></td>

            <td align="left"><code>263</code></td>
          </tr>

          <tr>
            <td align="left"><code>K_SHIFTED</code></td>

            <td align="left"><code>264</code></td>
          </tr>

          <tr>
            <td align="left"><code>K_ALTGR</code></td>

            <td align="left"><code>265</code></td>
          </tr>
        </tbody>
      </table>
    </div>
  </div><br class="table-break">

  <h4><a name="id488576" id="id488576"></a>Key text</h4>

  <p>The key text is simply the character (or characters) that you want to appear on the key cap. This will usually be the same as the
  characters generated when the key is touched, unless contextual rules are used to generate output according to a multi-key sequence, as
  will be true for the GFF Amharic keyboard. Unicode characters can be specified either as a string using a target font or using the
  standard hex notation <code>\uxxxx</code>. This may be sometimes more convenient, for example, for characters from an uninstalled font, or for
  diacritic characters that do not render well alone.</p>

  <p>A number of special text labels are recognized as identifying special purpose keys, such as Shift, Backspace, Enter, etc., for which
  icons are more appropriately used than a text label. A special font including these icons is included with Keyman and automatically
  embedded and used in any web page using Keyman. The list of icons in the font will probably be extended in future, but for now the
  following special labels are recognized:</p>

  <div class="table">
    <a name="id488574" id="id488574"></a>

    <p class="title"><b>Table 2.2. </b></p>

    <div class="table-contents">
      <table border="1">
        <colgroup>
          <col>
          <col>
        </colgroup>

        <thead>
          <tr>
            <th align="left">Text String</th>
            <th align="left">Key Purpose</th>
          </tr>
        </thead>

        <tbody>
          <tr>
            <td align="left"><code>*Shift*</code></td>
            <td align="left">Shift key image (inactive)</td>
          </tr>

          <tr>
            <td align="left"><code>*Enter*</code></td>
            <td align="left">Return</td>
          </tr>

          <tr>
            <td align="left"><code>*Tab*</code></td>
            <td align="left">Move to next input element in tab order</td>
          </tr>

          <tr>
            <td align="left"><code>*BkSp*</code></td>

            <td align="left">Backspace</td>
          </tr>

          <tr>
            <td align="left"><code>*Menu*</code></td>
            <td align="left">Display the language menu</td>
          </tr>

          <tr>
            <td align="left"><code>*Hide*</code></td>
            <td align="left">Hide the virtual keyboard</td>
          </tr>

          <tr>
            <td align="left"><code>*Alt*</code></td>
            <td align="left">Alt key caption</td>
          </tr>

          <tr>
            <td align="left"><code>*Ctrl*</code></td>
            <td align="left">Control key caption</td>
          </tr>

          <tr>
            <td align="left"><code>*Caps*</code></td>
            <td align="left">Caps Lock caption</td>
          </tr>

          <tr>
            <td align="left"><code>*ABC*</code></td>
            <td align="left">Select the upper case alphabetic layer</td>
          </tr>

          <tr>
            <td align="left"><code>*abc*</code></td>
            <td align="left">Return to the default (alphabetic) keyboard layer</td>
          </tr>

          <tr>
            <td align="left"><code>*123*</code></td>
            <td align="left">Select a numeric keyboard layer</td>
          </tr>

          <tr>
            <td align="left"><code>*Symbol*</code></td>
            <td align="left">Select a layer with various non-letter symbols</td>
          </tr>

          <tr>
            <td align="left"><code>*Currency*</code></td>
            <td align="left">Select a layer with currency symbols</td>
          </tr>

          <tr>
            <td align="left"><code>*Shifted*</code></td>
            <td align="left">Active Shift key image</td>
          </tr>

          <tr>
            <td align="left"><code>*AltGr*</code></td>
            <td align="left">Select right Alt modifier state</td>
          </tr>

          <tr>
            <td align="left"><code>*TabLeft*</code></td>
            <td align="left">Go back to previous input element in tab order</td>
          </tr>
        </tbody>
      </table>
    </div>
  </div><br class="table-break">

  <h4><a name="id488826" id="id488826"></a>Key type</h4>

  <p>The general appearance of each key is determined by the key type, which is selected (in Keyman Developer 9) from a drop-down
  list:</p>

  <div class="table">
    <a name="id488808" id="id488808"></a>

    <p class="title"><b>Table 2.3. </b></p>

    <div class="table-contents">
      <table border="1">
        <colgroup>
          <col>
          <col>
        </colgroup>

        <thead>
          <tr>
            <th align="left">Key Type</th>
            <th align="left">Value</th>
          </tr>
        </thead>

        <tbody>
          <tr>
            <td align="left">Default (normal) key</td>
            <td align="left"><code>0</code></td>
          </tr>

          <tr>
            <td align="left">Special (shift) key</td>
            <td align="left"><code>1</code></td>
          </tr>

          <tr>
            <td align="left">Active special key</td>
            <td align="left"><code>2</code></td>
          </tr>

          <tr>
            <td align="left">Dead-key</td>
            <td align="left"><code>8</code></td>
          </tr>

          <tr>
            <td align="left">Blank key</td>
            <td align="left"><code>9</code></td>
          </tr>

          <tr>
            <td align="left">Spacer</td>
            <td align="left"><code>10</code></td>
          </tr>
        </tbody>
      </table>
    </div>
  </div><br class="table-break">

  <p>The colour, shading and borders of each key type is actually set by a style sheet which can be customized by the page developer.</p>

  <h4><a name="id488904" id="id488904"></a>font-family</h4>

  <p>If a different font is required for a particular key text, the <code>font-family</code> name can be specified. The font used to display icons for
  the special keys (as mentioned above) does not need to be specified, as it will be automatically applied to a key that uses any of the
  special key text labels.</p>

  <h4><a name="id488940" id="id488940"></a>font-size</h4>

  <p>If a particular key cap text requires a different font size from the default for the layout, it should be specified in em units.
  This can be helpful if a the key text is either an unusually large character or, alternatively, a word or string of several characters
  that would not normally fit on the key.</p>

  <h4><a name="id488924" id="id488924"></a>width</h4>

  <p>The layout is scaled to fit the widest row of keys in the device width, assuming a default key width of 100 units. Keys that are to
  be wider or narrower than the default width should have width specified as a percentage of the default width. For any key row that is
  narrower than the widest row, the width of the last key in the row will be automatically increased to align the right hand side of the
  key with the key with the right edge of the keyboard. However, where this is not wanted, a "spacer" key can be inserted to
  leave a visible space instead. As shown in the above layouts, where the spacer key appears on the designer screen as a narrow key, but
  will not be visible in actual use.</p>

  <h4><a name="id488914" id="id488914"></a>pad</h4>

  <p>Padding to the left of each key can be adjusted, and specified as a percentage of the default key width. If not specified, a
  standard padding of 5% of the key width is used between adjacent keys.</p>

  <h4><a name="id488916" id="id488916"></a>layer</h4>

  <p>To simplify correspondence with desktop keyboards and avoid the need for using a separate keyboard mapping program, touch layout
  keys can specify a desktop keyboard layer that the keystroke should be interpreted as coming from. Layer names of <code>shift</code>, <code>ctrl</code>, <code>alt</code>,
  <code>ctrlshift</code>, <code>altshift</code>, <code>ctrlalt</code> and <code>ctrlaltshift</code> can be used to simulate use of the appropriate modifier keys when processing rules.</p>

  <h4><a name="id488908" id="id488908"></a>nextlayer</h4>

  <p>The virtual keys <code>K_SHIFT</code>, <code>K_CONTROL</code>, <code>K_MENU</code>, etc. are normally used to switch to another key layer, which is implied by the key
  code. The left and right variants of those key codes, and also additional layer-switching keys mentioned above (<code>K_NUMERALS</code>, <code>K_SYMBOLS</code>,
  <code>K_CURRENCIES</code>, <code>K_ALTGR</code>) can also be used to automatically switch to the appropriate key layer instead of outputting a character.
  However, it is sometimes useful for a key to output a character first, then switch to a new layer, for example, switching back to the
  default keyboard layer after a punctuation key on a secondary layer had been used. Specifying the <code>nextlayer</code> for a key allows a
  different key layer to be selected automatically following the output of the key. Of course, that can be manually overridden by
  switching to a different layer if preferred.</p>

  <p>Another way the <code>nextlayer</code> property can be used is for a non-standard layer switching key. So, for example, for the GFF Amharic
  keyboard phone layout, switching back to the base layer uses a <code>T_ALPHA</code> key code, in which <code>nextlayer</code> is set as default. In this case, it
  is also necessary to add a rule to the keyboard program:</p>

  <pre class='language-keyman'><code>+ [T_ALPHA] > nul</code></pre>

  <p>to ensure that the key's scan code is ignored by the keyboard mapping.</p>

  <h4><a name="id488949" id="id488949"></a>subkey</h4>

  <p>Arrays of 'subkeys' or pop-up keys can be defined for any key, and will appear momentarily after the key is touched if not
  immediately released. This provides a major advantage over physical desktop keyboards in that many more keys can be made available from
  a single layer, without cluttering up the basic appearance of the layout. For the GFF Amharic keyboard, we have already noted how such
  subkey arrays are used to manage the extra keys that, on the desktop keyboard, would appear in the shift layer. But they are also used
  to provide another way to enter the two different types of each syllable-initial vowels (glottal or pharyngeal), as a visual
  alternative to pressing the key twice.</p>

  <p>The same properties that are defined for standard keys can also be specified for each subkey except that the width of each key in a
  subkey array will always be the same as the width of the key that causes the subkeys to be shown, and key spacing always uses the
  default padding value.</p>

  <p>The GFF Amharic keyboard, like many others, is mnemonic, so it is useful to also display the standard key cap letter that would
  appear on the key of a desktop keyboard. This is enabled globally in the On-Screen layout editor and applies to both the On-Screen
  keyboard and touch layouts.</p>

  <h4><a name="id488961" id="id488961"></a>Representing (and editing) the visual layout with JSON code</h4>

  <p>In case you are wondering, 'Why do I need to know that?', the reason is that, just as with keyboard mapping code, it is
  sometimes easier to edit a text specification than to use the GUI layout design tool. Keyman Developer 9 switches seamlessly between
  the visual layout tool and the code editor, unless, of course, careless editing of the code results in invalid JSON syntax!</p>

  <p>There are a few things that it is actually quite hard to do with the visual layout tool, but simple with the code editor. One
  obvious example would be to copy a tablet layout and use that as a starting point for a phone layout, or copying an entire layout from
  one keyboard to another. Another use is for is renaming a layer - it is trivial to do this in the code editor, but not with the GUI
  interface. Finding a particular key in an unfamiliar layout, or locating a key by width, and changing properties, is much easier with
  the code editor than with the visual editor.</p>

  <p>The GFF Amharic phone layout code starts as:</p>
  <pre class="language-javascript"><code>
  {
    "phone": {
      "font": "Tahoma",
      "layer": [{
        "id": "default",
        "row": [{
          "id": 1,
          "key": [{
              "id": "K_Q",
              "text": "ቅ",
              "pad": "0"
            }, {
              "id": "K_W",
              "text": "ው"
            },

  . . . 
</code></pre>

<p>As long as standard JSON syntax is remembered - nested braces {…}, quoted strings "…" for both element names and values,
element or object arrays in square brackets […], and no trailing comma after the last element in an array - it is quite easy to
understand a layout, which will usually comprise a list of two separate JSON objects for tablet and phone.</p>

<p>Now you're ready to create a great touch layout for your own Keyman keyboard!</p>

<p>Other articles on developing touch layouts:</p>

<ul>
  <li><a href="creating-a-touch-keyboard-layout-for-amharic-with-keyman-developer-9">Creating a touch keyboard layout for Amharic - part 1</a></li>
  <li><a href="../test/how-to-test-your-keyboard-layout-with-keyman-developer-9-touch-and-desktop">How to test your keyboard layout — touch and desktop</a></li>
  <li><a href='../test/how-to-test-your-touch-layout-in-the-google-chrome-mobile-emulator'>How to test your touch layout in the Google Chrome mobile emulator</a></li>
</ul>

<p>You can distribute your keyboard to other users by following the instructions in these two articles:</p>

<ul>
  <li><a href="../distribute/mobile-apps">Distributing custom keyboards for Keyman mobile apps</a></li>
</ul>
